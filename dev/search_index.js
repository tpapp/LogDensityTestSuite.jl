var documenterSearchIndex = {"docs":
[{"location":"#LogDensityTestSuite","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"","category":"section"},{"location":"#LogDensityTestSuite.LogDensityTestSuite","page":"LogDensityTestSuite","title":"LogDensityTestSuite.LogDensityTestSuite","text":"LogDensityTestSuite.jl\n\n(Image: lifecycle) (Image: build) (Image: codecov.io) (Image: DOI)\n\nConstruct distributions that support\n\nthe LogDensityProblems.jl interface (with gradients),\ngenerating “samples” deterministically using low-discrepancy sequences.\n\nGradient calculations use optimized closed formss instead automatic differentiation.\n\nThis package was developed mainly for testing DynamicHMC.jl, but other projects may also find it useful.\n\nAcknowledgements\n\nThe development of this package was partially supported by the Austrian National Bank Jubileumsfonds Projekt 18847.\n\n\n\n\n\n","category":"module"},{"location":"#Overview","page":"LogDensityTestSuite","title":"Overview","text":"","category":"section"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"This package is helpful in defining a family of distributions defined on mathbbR^n, each with the following properties:","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"samples can be drawn from the distribution using quasi-random methods (low-discrepancy Sobol sequences),\nthe log density and its gradient can be calculated for each coordinate efficiently and accurately, without relying on automatic differentiation (using closed forms), implemented using the LogDensityProblems.jl interface.","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"This is achieved by constructing distributions using simple transformations that preserve these properties.","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"d = (funnel() ∘ shift([-1.0, 2.0]))(StandardMultivariateNormal(2))\nsamples(d, 10)","category":"page"},{"location":"#LogDensityTestSuite.samples","page":"LogDensityTestSuite","title":"LogDensityTestSuite.samples","text":"samples(ℓ, N)\n\n\nDraw N independent samples from ℓ, as columns of a matrix.\n\n\n\n\n\n","category":"function"},{"location":"#Constructing-distributions","page":"LogDensityTestSuite","title":"Constructing distributions","text":"","category":"section"},{"location":"#Primitives","page":"LogDensityTestSuite","title":"Primitives","text":"","category":"section"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"All distributions are constructed from primitives. For practical purposes, these are isotropic extensions of univariate distributions with known density (& its derivative) and inverse quantile functions. Currently the package contains only one primitive, from the standard normal distribution, but similar distributions would be easy to define. However, it is preferred to construct more complex distributions using transformations.","category":"page"},{"location":"#LogDensityTestSuite.StandardMultivariateNormal","page":"LogDensityTestSuite","title":"LogDensityTestSuite.StandardMultivariateNormal","text":"Standard multivariate normal with the given dimension K.\n\n\n\n\n\n","category":"type"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"We introduce the convention used for illustrating two-dimensional distributions below: lines increasing thickness are contour plots of the density, containing the 90%, ..., 10% highest posterior density regions:","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"const N2 = StandardMultivariateNormal(2)\ncontour_plot(N2) #hide","category":"page"},{"location":"#transformations","page":"LogDensityTestSuite","title":"Transformations","text":"","category":"section"},{"location":"#LogDensityTestSuite.linear","page":"LogDensityTestSuite","title":"LogDensityTestSuite.linear","text":"linear(A)\n\n\nTransform a distribution on x to y = Ax, where A is a conformable square matrix.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"A = [0.5 0.8;\n     0.0 0.7]\nD =  linear(A)(N2)\ncontour_plot(D) # hide","category":"page"},{"location":"#LogDensityTestSuite.shift","page":"LogDensityTestSuite","title":"LogDensityTestSuite.shift","text":"shift(b)\n\n\nTransform a distribution on x to y = x + b, where b is a conformable vector.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"b = [1.0, 0.0]\nD = (shift(b) ∘ linear(A))(N2)\ncontour_plot(D) # hide","category":"page"},{"location":"#LogDensityTestSuite.elongate","page":"LogDensityTestSuite","title":"LogDensityTestSuite.elongate","text":"elongate(k)\n\n\nTransform a distribution on x to y = (1 + x²)ᵏx where   is the Euclidean norm and k is a real number. k > 0 values make the tails heavier.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"D = (shift(-2.2*b) ∘ elongate(1.2) ∘ shift(b) ∘ linear(I(2) ./ 4))(N2)\ncontour_plot(D) # hide","category":"page"},{"location":"#LogDensityTestSuite.funnel","page":"LogDensityTestSuite","title":"LogDensityTestSuite.funnel","text":"funnel()\n\n\nTransform the distribution with the mapping x ↦ y, such that y[begin] = x[begin] and y[i] = x[i] exp(x[begin]) for all other indices.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"D = funnel()(N2)\ncontour_plot(D) # hide","category":"page"},{"location":"#Mixtures","page":"LogDensityTestSuite","title":"Mixtures","text":"","category":"section"},{"location":"#LogDensityTestSuite.mix","page":"LogDensityTestSuite","title":"LogDensityTestSuite.mix","text":"mix(α, ℓ1, ℓ2)\n\n\nA mixture of two densities: ℓ1(x) with probability α(x), and ℓ2(x) with probability 1-α(x). α needs to implement weight_and_gradient.\n\n\n\n\n\n","category":"function"},{"location":"#LogDensityTestSuite.weight_and_gradient","page":"LogDensityTestSuite","title":"LogDensityTestSuite.weight_and_gradient","text":"weight_and_gradient(α, x)\n\n\nReturn α(x) and ∇α(x), where α is the mixture weight on the first distribution.\n\nPublic, but not exported.\n\n\n\n\n\n","category":"function"},{"location":"#LogDensityTestSuite.directional_weight","page":"LogDensityTestSuite","title":"LogDensityTestSuite.directional_weight","text":"directional_weight(y)\n\n\nRepresents the weight α(x) = logistic(dot(x, y)). The Euclidean norm of y is related to the slope of the gradient of α in the given direction.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"Example with constant weight:","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"D = mix(0.5, \n        (shift([-0.7, 0.3]) ∘ linear(I(2) ./ 1.5))(N2),\n        (shift([0.7, 0.7]) ∘ linear(I(2) ./ 3))(N2))\ncontour_plot(D) # hide        ","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"D = mix(directional_weight([1,1]), \n        (shift([-0.7, 0.3]) ∘ linear(I(2) ./ 1.5))(N2),\n        (shift([0.7, 0.7]) ∘ linear(I(2) ./ 3))(N2))\ncontour_plot(D) # hide        ","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"New kinds of mixtures that depend on coordinates can be created by implementing the methods below.","category":"page"},{"location":"","page":"LogDensityTestSuite","title":"LogDensityTestSuite","text":"LogDensityTestSuite.weight\nLogDensityTestSuite.weight_and_gradient","category":"page"},{"location":"#Diagnostics","page":"LogDensityTestSuite","title":"Diagnostics","text":"","category":"section"},{"location":"#LogDensityTestSuite.two_sided_pvalues","page":"LogDensityTestSuite","title":"LogDensityTestSuite.two_sided_pvalues","text":"two_sided_pvalues(ubc; ess_correction)\n\n\nCalculate two-sided p-values for bin counts.\n\nUses a normal approxiation with continuity correction.\n\nWhen ess_correction = true (the default), the standard deviation is calculated using the the effective sample size.\n\n\n\n\n\n","category":"function"},{"location":"#LogDensityTestSuite.print_ascii_plot","page":"LogDensityTestSuite","title":"LogDensityTestSuite.print_ascii_plot","text":"print_ascii_plot(\n    io,\n    ubc;\n    canvas_width,\n    p_colname,\n    bin_colname,\n    α,\n    count_colname,\n    padding,\n    ess_correction\n)\n\n\nPrint an ASCII plot to io with statistics from the given univariate bin counts. When the first argument is a String, return the output as a string instead of printing.\n\nKeyword arguments\n\ncanvas_width: width of the canvas for the plot\np_colname: column name for p-values (the actual value printed is -log10(p))\nbin_colname: column name for bin indices\ncount_colname: column name for counts\nα: two markers (with ( and ) are placed at the quantiles α and 1-α\npadding: enlargement factor for canvas\n\nWhen ess_correction = true (the default), the standard deviation is calculated using the the effective sample size.\n\n\n\n\n\n","category":"function"},{"location":"#LogDensityTestSuite.bin_counts","page":"LogDensityTestSuite","title":"LogDensityTestSuite.bin_counts","text":"bin_counts(uqb, xs)\n\n\nCalculate univariate bin counts of xs (a vector of real numbers), using the given quantile boundaries. Effective sample size is saved.\n\n\n\n\n\n","category":"function"},{"location":"#LogDensityTestSuite.quantile_boundaries","page":"LogDensityTestSuite","title":"LogDensityTestSuite.quantile_boundaries","text":"quantile_boundaries(xs, K)\n\n\nQuantiles 1K  (K-1)K of real numbers xs, as a UnivariateQuantileBoundaries object.\n\n\n\n\n\n","category":"function"}]
}
